"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateContextFile = exports.addToGitignore = exports.createDefaultConfig = exports.isNodeError = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const collectContext_1 = require("./collectContext");
const config_1 = require("./config");
const rootDir = process.cwd();
const configFilePath = path.join(rootDir, config_1.CONFIG_FILE_NAME);
const outputFilePath = path.join(rootDir, config_1.OUTPUT_FILE_NAME);
/**
 * Type guard to check if an error is a Node.js error with a code.
 *
 * @param error - The error to check.
 * @returns Whether the error is a Node.js error with a code.
 */
function isNodeError(error) {
    return typeof error === 'object' && error !== null && 'code' in error;
}
exports.isNodeError = isNodeError;
/**
 * Creates a default configuration file if it doesn't exist.
 *
 * @param configPath - The path to the configuration file.
 */
const createDefaultConfig = (configPath) => {
    if (!fs.existsSync(configPath)) {
        fs.writeFileSync(configPath, JSON.stringify(config_1.defaultConfig, null, 2), 'utf-8');
    }
};
exports.createDefaultConfig = createDefaultConfig;
/**
 * Adds entries to the .gitignore file if they are not already present.
 *
 * @param params - The parameters for adding entries to the .gitignore file.
 */
const addToGitignore = ({ gitignorePath, entries }) => {
    let gitignoreContent = '';
    if (fs.existsSync(gitignorePath)) {
        gitignoreContent = fs.readFileSync(gitignorePath, 'utf-8');
    }
    const newEntries = entries.filter(entry => !gitignoreContent.includes(entry));
    if (newEntries.length > 0) {
        gitignoreContent += `\n${newEntries.join('\n')}\n`;
        fs.writeFileSync(gitignorePath, gitignoreContent, 'utf-8');
    }
};
exports.addToGitignore = addToGitignore;
/**
 * Groups paths by their folders.
 *
 * @param paths - Array of paths to group.
 * @returns A string with grouped paths.
 */
const groupPathsByFolder = (paths) => {
    const grouped = {};
    paths.forEach((p) => {
        const dir = path.dirname(p);
        if (!grouped[dir]) {
            grouped[dir] = [];
        }
        grouped[dir].push(p);
    });
    return Object.entries(grouped)
        .map(([folder, files]) => `${folder}/\n${files.map(file => `- ${file}`).join('\n')}`)
        .join('\n\n');
};
/**
 * Generates the context file based on the current configuration.
 */
const generateContextFile = () => {
    let config;
    try {
        config = JSON.parse(fs.readFileSync(configFilePath, 'utf-8'));
    }
    catch (error) {
        if (isNodeError(error) && error.code === 'ENOENT') {
            console.warn(`Warning: ${config_1.CONFIG_FILE_NAME} not found. Creating default configuration.`);
            (0, exports.createDefaultConfig)(configFilePath);
            config = JSON.parse(fs.readFileSync(configFilePath, 'utf-8'));
        }
        else {
            throw error;
        }
    }
    try {
        if (fs.existsSync(outputFilePath)) {
            fs.unlinkSync(outputFilePath);
        }
    }
    catch (error) {
        if (isNodeError(error) && error.code === 'EBUSY') {
            console.error(`Error: The file ${outputFilePath} is currently in use and cannot be deleted.`);
            return;
        }
        throw error;
    }
    const { content, paths } = (0, collectContext_1.collectContext)(config.include.map((item) => ({ path: item })), rootDir, config.exclude || [], config.allowedExtensions || []);
    const header = `# Included files:\n${groupPathsByFolder(paths)}\n\n`;
    fs.writeFileSync(outputFilePath, header + content, 'utf-8');
};
exports.generateContextFile = generateContextFile;
